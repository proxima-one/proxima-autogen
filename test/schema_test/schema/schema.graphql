
scalar BigDecimal
scalar BigInt
type Query {
DPoolList(id: ID!, prove: Boolean): DPoolList!
DPoolLists(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [DPoolList]!
DPoolListSearch(queryText: String!, prove: Boolean): [DPoolList]!
DPool(id: ID!, prove: Boolean): DPool!
DPools(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [DPool]!
DPoolSearch(queryText: String!, prove: Boolean): [DPool]!
User(id: ID!, prove: Boolean): User!
Users(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [User]!
UserSearch(queryText: String!, prove: Boolean): [User]!
UserTotalDeposit(id: ID!, prove: Boolean): UserTotalDeposit!
UserTotalDeposits(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [UserTotalDeposit]!
UserTotalDepositSearch(queryText: String!, prove: Boolean): [UserTotalDeposit]!
Deposit(id: ID!, prove: Boolean): Deposit!
Deposits(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [Deposit]!
DepositSearch(queryText: String!, prove: Boolean): [Deposit]!
Funder(id: ID!, prove: Boolean): Funder!
Funders(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [Funder]!
FunderSearch(queryText: String!, prove: Boolean): [Funder]!
FunderTotalInterest(id: ID!, prove: Boolean): FunderTotalInterest!
FunderTotalInterests(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [FunderTotalInterest]!
FunderTotalInterestSearch(queryText: String!, prove: Boolean): [FunderTotalInterest]!
Funding(id: ID!, prove: Boolean): Funding!
Fundings(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [Funding]!
FundingSearch(queryText: String!, prove: Boolean): [Funding]!
MPHHolder(id: ID!, prove: Boolean): MPHHolder!
MPHHolders(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [MPHHolder]!
MPHHolderSearch(queryText: String!, prove: Boolean): [MPHHolder]!
MPH(id: ID!, prove: Boolean): MPH!
MPHs(where: String, order_by: String, asc: Boolean, first: Int, last: Int, limit: Int, prove: Boolean): [MPH]!
MPHSearch(queryText: String!, prove: Boolean): [MPH]!

}

type Mutation {
UpdateDPoolList(input: DPoolListInput!): Boolean 
UpdateDPool(input: DPoolInput!): Boolean 
UpdateUser(input: UserInput!): Boolean 
UpdateUserTotalDeposit(input: UserTotalDepositInput!): Boolean 
UpdateDeposit(input: DepositInput!): Boolean 
UpdateFunder(input: FunderInput!): Boolean 
UpdateFunderTotalInterest(input: FunderTotalInterestInput!): Boolean 
UpdateFunding(input: FundingInput!): Boolean 
UpdateMPHHolder(input: MPHHolderInput!): Boolean 
UpdateMPH(input: MPHInput!): Boolean 

}

type DPoolList {
id: ID
pools: [DPool]  @goField(forceResolver: true)
DPoolIDs: [String]
numPools: Int
numUsers: Int
numActiveUsers: Int
numFunders: Int
proof: Proof 
} 

input DPoolListInput {
id: ID
DPoolIDs: [String]
numPools: Int
numUsers: Int
numActiveUsers: Int
numFunders: Int
}

type DPool {
id: ID
address: String
moneyMarket: String
stablecoin: String
interestModel: String
users: [User]  @goField(forceResolver: true)
UserIDs: [String]
numUsers: Int
deposits: [Deposit]  @goField(forceResolver: true)
DepositIDs: [String]
numDeposits: Int
numActiveDeposits: String
totalActiveDeposit: String
totalHistoricalDeposit: String
totalInterestPaid: String
unfundedDepositAmount: String
funders: [Funder]  @goField(forceResolver: true)
FunderIDs: [String]
numFunders: String
fundings: [Funding]  @goField(forceResolver: true)
FundingIDs: [String]
numFundings: String
MinDepositPeriod: Float
MaxDepositPeriod: Float
MinDepositAmount: Float
MaxDepositAmount: Float
mphMintingMultiplier: Float
mphDepositorRewardMultiplier: Float
mphFunderRewardMultiplier: Float
oneYearInterestRate: Float
surplus: String
moneyMarketIncomeIndex: String
oracleInterestRate: String
proof: Proof 
} 

input DPoolInput {
id: ID
address: String
moneyMarket: String
stablecoin: String
interestModel: String
UserIDs: [String]
numUsers: Int
DepositIDs: [String]
numDeposits: Int
numActiveDeposits: String
totalActiveDeposit: String
totalHistoricalDeposit: String
totalInterestPaid: String
unfundedDepositAmount: String
FunderIDs: [String]
numFunders: String
FundingIDs: [String]
numFundings: String
MinDepositPeriod: Float
MaxDepositPeriod: Float
MinDepositAmount: Float
MaxDepositAmount: Float
mphMintingMultiplier: Float
mphDepositorRewardMultiplier: Float
mphFunderRewardMultiplier: Float
oneYearInterestRate: Float
surplus: String
moneyMarketIncomeIndex: String
oracleInterestRate: String
}

type User {
id: ID
address: String
pools: [DPool]  @goField(forceResolver: true)
DPoolIDs: [String]
numPools: String
deposits: [Deposit]  @goField(forceResolver: true)
DepositIDs: [String]
numDeposits: String
numActiveDeposits: String
totalDepositByPool: [UserTotalDeposit]  @goField(forceResolver: true)
UserTotalDepositIDs: [String]
totalMPHEarned: String
totalMPHPaidBack: String
proof: Proof 
} 

input UserInput {
id: ID
address: String
DPoolIDs: [String]
numPools: String
DepositIDs: [String]
numDeposits: String
numActiveDeposits: String
UserTotalDepositIDs: [String]
totalMPHEarned: String
totalMPHPaidBack: String
}

type UserTotalDeposit {
id: ID
user: User  @goField(forceResolver: true)
UserID: String
pool: DPool  @goField(forceResolver: true)
DPoolID: String
totalActiveDeposit: String
totalHistoricalDeposit: String
totalInterestEarned: String
totalHistoricalInterestEarned: String
proof: Proof 
} 

input UserTotalDepositInput {
id: ID
UserID: String
DPoolID: String
totalActiveDeposit: String
totalHistoricalDeposit: String
totalInterestEarned: String
totalHistoricalInterestEarned: String
}

type Deposit {
id: ID
nftID: String
user: User  @goField(forceResolver: true)
UserID: String
pool: DPool  @goField(forceResolver: true)
DPoolID: String
amount: String
maturationTimestamp: String
active: Boolean
depositTimestamp: String
interestEarned: String
fundingID: String
mintMPHAmount: String
takeBackMPHAmount: String
initialMoneyMarketIncomeIndex: String
proof: Proof 
} 

input DepositInput {
id: ID
nftID: String
UserID: String
DPoolID: String
amount: String
maturationTimestamp: String
active: Boolean
depositTimestamp: String
interestEarned: String
fundingID: String
mintMPHAmount: String
takeBackMPHAmount: String
initialMoneyMarketIncomeIndex: String
}

type Funder {
id: ID
address: String
pools: [DPool]  @goField(forceResolver: true)
DPoolIDs: [String]
numPools: String
fundings: [Funding]  @goField(forceResolver: true)
FundingIDs: [String]
numFundings: String
totalMPHEarned: String
totalInterestByPool: [FunderTotalInterest]  @goField(forceResolver: true)
FunderTotalInterestIDs: [String]
proof: Proof 
} 

input FunderInput {
id: ID
address: String
DPoolIDs: [String]
numPools: String
FundingIDs: [String]
numFundings: String
totalMPHEarned: String
FunderTotalInterestIDs: [String]
}

type FunderTotalInterest {
id: ID
funder: Funder  @goField(forceResolver: true)
FunderID: String
pool: DPool  @goField(forceResolver: true)
DPoolID: String
totalDeficitFunded: String
totalHistoricalDeficitFunded: String
totalInterestEarned: String
totalHistoricalInterestEarned: String
totalRecordedFundedDepositAmount: String
proof: Proof 
} 

input FunderTotalInterestInput {
id: ID
FunderID: String
DPoolID: String
totalDeficitFunded: String
totalHistoricalDeficitFunded: String
totalInterestEarned: String
totalHistoricalInterestEarned: String
totalRecordedFundedDepositAmount: String
}

type Funding {
id: ID
nftID: String
funder: Funder  @goField(forceResolver: true)
FunderID: String
pool: DPool  @goField(forceResolver: true)
DPoolID: String
fromDepositID: String
toDepositID: String
active: Boolean
recordedFundedDepositAmount: String
recordedMoneyMarketIncomeIndex: String
initialFundedDepositAmount: String
fundedDeficitAmount: String
totalInterestEarned: String
mintMPHAmount: String
proof: Proof 
} 

input FundingInput {
id: ID
nftID: String
FunderID: String
DPoolID: String
fromDepositID: String
toDepositID: String
active: Boolean
recordedFundedDepositAmount: String
recordedMoneyMarketIncomeIndex: String
initialFundedDepositAmount: String
fundedDeficitAmount: String
totalInterestEarned: String
mintMPHAmount: String
}

type MPHHolder {
id: ID
address: String
mphBalance: String
stakedMPHBalance: String
totalHistoricalReward: String
proof: Proof 
} 

input MPHHolderInput {
id: ID
address: String
mphBalance: String
stakedMPHBalance: String
totalHistoricalReward: String
}

type MPH {
id: ID
totalSupply: String
totalStakedMPHBalance: String
totalHistoricalReward: String
rewardPerSecond: String
rewardPerMPHPerSecond: String
proof: Proof 
} 

input MPHInput {
id: ID
totalSupply: String
totalStakedMPHBalance: String
totalHistoricalReward: String
rewardPerSecond: String
rewardPerMPHPerSecond: String
}

type Proof {
  root: String
  proof: String
}

directive @hasAuthentication on MUTATION | SUBSCRIPTION | QUERY
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
